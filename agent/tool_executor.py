"""
agent/tool_executor.py
Executes tool calls from Claude API responses
"""

from typing import Dict, Any
from pathlib import Path
from datetime import datetime
import json

from mcp_servers import get_mcp_config
from utils.logger import get_logger

logger = get_logger(__name__)


class ToolExecutor:
    """
    Executes tool calls from Claude's tool_use blocks
    """
    
    def __init__(self):
        """Initialize tool executor"""
        self.mcp_config = get_mcp_config()
        self.output_dir = self.mcp_config.get_output_dir()
        
        logger.info(f"ToolExecutor initialized (output_dir: {self.output_dir})")
    
    def execute(self, tool_name: str, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a tool call
        
        Args:
            tool_name: Name of the tool to execute
            tool_input: Input parameters for the tool
            
        Returns:
            Result dictionary with 'success' and either 'result' or 'error'
        """
        logger.info(f"Executing tool: {tool_name}")
        logger.debug(f"  Input: {tool_input}")
        
        try:
            # Route to appropriate handler
            if tool_name == "create_file":
                return self._create_file(tool_input)
            
            elif tool_name == "read_document":
                return self._read_document(tool_input)
            
            elif tool_name == "list_generated_files":
                return self._list_generated_files(tool_input)
            
            elif tool_name == "web_search":
                return self._web_search(tool_input)
            
            else:
                logger.error(f"Unknown tool: {tool_name}")
                return {
                    "success": False,
                    "error": f"Unknown tool: {tool_name}"
                }
        
        except Exception as e:
            logger.error(f"Tool execution failed: {e}", exc_info=True)
            return {
                "success": False,
                "error": f"Tool execution error: {str(e)}"
            }
    
    def _create_file(self, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a file with content
        
        Args:
            tool_input: {filename, content, subdirectory}
            
        Returns:
            Success/error result
        """
        filename = tool_input.get("filename")
        content = tool_input.get("content")
        subdirectory = tool_input.get("subdirectory")
        
        # Validate required parameters
        if not filename:
            return {"success": False, "error": "Missing required parameter: filename"}
        if not content:
            return {"success": False, "error": "Missing required parameter: content"}
        if not subdirectory:
            return {"success": False, "error": "Missing required parameter: subdirectory"}
        
        # Validate subdirectory
        valid_subdirs = ["summaries", "reports", "extracts", "templates"]
        if subdirectory not in valid_subdirs:
            return {
                "success": False,
                "error": f"Invalid subdirectory: {subdirectory}. Must be one of: {valid_subdirs}"
            }
        
        # Build full path
        subdir_path = self.output_dir / subdirectory
        subdir_path.mkdir(parents=True, exist_ok=True)
        
        filepath = subdir_path / filename
        
        # Add metadata header
        metadata_header = f"""---
Generated by: InsightOS
Date: {datetime.now().isoformat()}
File: {filename}
Location: {subdirectory}/
---

"""
        
        # Add footer
        footer = f"""

---
*Generated by InsightOS on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        full_content = metadata_header + content + footer
        
        # Write file
        try:
            filepath.write_text(full_content, encoding='utf-8')
            
            logger.info(f"✓ File created: {filepath}")
            
            return {
                "success": True,
                "result": f"File created successfully at: {filepath}\n\nThe file is now visible in the Generated Files browser."
            }
        
        except Exception as e:
            logger.error(f"Failed to write file: {e}")
            return {
                "success": False,
                "error": f"Failed to write file: {str(e)}"
            }
    
    def _read_document(self, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        Read a document from the user's indexed files
        
        Args:
            tool_input: {filepath}
            
        Returns:
            Success/error result with file content
        """
        filepath = tool_input.get("filepath")
        
        if not filepath:
            return {"success": False, "error": "Missing required parameter: filepath"}
        
        try:
            path = Path(filepath)
            
            if not path.exists():
                return {
                    "success": False,
                    "error": f"File not found: {filepath}"
                }
            
            # Check file size (limit to 100KB for safety)
            file_size = path.stat().st_size
            if file_size > 100 * 1024:
                return {
                    "success": False,
                    "error": f"File too large ({file_size} bytes). Maximum 100KB."
                }
            
            # Read file
            content = path.read_text(encoding='utf-8', errors='ignore')
            
            logger.info(f"✓ Document read: {filepath} ({len(content)} chars)")
            
            return {
                "success": True,
                "result": f"Content of {path.name}:\n\n{content}"
            }
        
        except Exception as e:
            logger.error(f"Failed to read document: {e}")
            return {
                "success": False,
                "error": f"Failed to read document: {str(e)}"
            }
    
    def _list_generated_files(self, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        List generated files
        
        Args:
            tool_input: {subdirectory}
            
        Returns:
            Success/error result with file list
        """
        subdirectory = tool_input.get("subdirectory", "all")
        
        try:
            if subdirectory == "all":
                # List all files in all subdirectories
                files = []
                for subdir in ["summaries", "reports", "extracts", "templates"]:
                    subdir_path = self.output_dir / subdir
                    if subdir_path.exists():
                        for file in subdir_path.iterdir():
                            if file.is_file():
                                files.append(f"{subdir}/{file.name}")
            else:
                # List files in specific subdirectory
                subdir_path = self.output_dir / subdirectory
                if not subdir_path.exists():
                    return {
                        "success": True,
                        "result": f"No files in {subdirectory}/ (directory doesn't exist yet)"
                    }
                
                files = [f.name for f in subdir_path.iterdir() if f.is_file()]
            
            if not files:
                return {
                    "success": True,
                    "result": f"No files found in {subdirectory}/"
                }
            
            file_list = "\n".join(f"  - {f}" for f in sorted(files))
            
            logger.info(f"✓ Listed {len(files)} files in {subdirectory}/")
            
            return {
                "success": True,
                "result": f"Generated files in {subdirectory}/:\n{file_list}"
            }
        
        except Exception as e:
            logger.error(f"Failed to list files: {e}")
            return {
                "success": False,
                "error": f"Failed to list files: {str(e)}"
            }
    
    def _web_search(self, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        Web search using Brave Search (if enabled)
        
        Args:
            tool_input: {query, count}
            
        Returns:
            Success/error result with search results
        """
        # Check if Brave Search is enabled
        if "brave-search" not in self.mcp_config.get_enabled_servers():
            return {
                "success": False,
                "error": "Brave Search is not enabled in MCP configuration"
            }
        
        query = tool_input.get("query")
        count = tool_input.get("count", 5)
        
        if not query:
            return {"success": False, "error": "Missing required parameter: query"}
        
        # TODO: Implement actual Brave Search API integration
        # For now, return a placeholder
        logger.warning("Brave Search not yet implemented")
        
        return {
            "success": False,
            "error": "Web search functionality not yet implemented. Configure Brave Search API key in settings."
        }


# Singleton instance
_tool_executor = None


def get_tool_executor() -> ToolExecutor:
    """
    Get singleton ToolExecutor instance
    
    Returns:
        ToolExecutor instance
    """
    global _tool_executor
    
    if _tool_executor is None:
        _tool_executor = ToolExecutor()
    
    return _tool_executor